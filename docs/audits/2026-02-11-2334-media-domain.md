# ELITE DOMAIN FORENSIC AUDIT — Media Domain

## 1. Executive Summary

The **media domain** (`src/domains/media/`) is the heart of the FlyLive Audio Server — it manages all WebRTC media transport, producer/consumer lifecycle, multi-router distribution, and active speaker detection. At **~1,136 lines across 5 files**, it is architecturally sound and well-engineered for the project's scale.

**Overall Score: 87 / 100** — Strong implementation with a few targeted improvements available.

The codebase shows evidence of recent, high-quality refactoring (CQ-001, CQ-002, PERF-001/002/003, ARCH-001/002 fixes are all noted inline). The multi-router cluster architecture is a sophisticated, correct approach to scaling past single-worker limits. No critical issues were found.

---

## 2. Context Metadata

| Key          | Value                          |
| ------------ | ------------------------------ |
| Branch       | `work`                         |
| Commit       | `a6d5087`                      |
| Node Version | `v24.12.0`                     |
| Audit Focus  | `src/domains/media/` (5 files) |
| Timestamp    | 2026-02-11T23:34 +05:00        |

---

## 3. Bootstrap Results

| Gate       | Result                   |
| ---------- | ------------------------ |
| Lint       | ✅ Clean                 |
| Typecheck  | ✅ Clean                 |
| Tests      | ✅ 66/66 passed (667ms)  |
| Build      | ✅ 138.86 KB ESM (60ms)  |
| TODOs      | ✅ None in media domain  |
| console.\* | ✅ None in media domain  |
| `any`      | ✅ No type erosion found |

---

## 4. Domain Coverage Matrix

| File                  | Lines | Tests | Test Coverage     |
| --------------------- | ----- | ----- | ----------------- |
| `media.handler.ts`    | 281   | 0     | ⚠️ Untested       |
| `routerManager.ts`    | 148   | 0     | ⚠️ Untested       |
| `activeSpeaker.ts`    | 144   | 0     | ⚠️ Untested       |
| `roomMediaCluster.ts` | 549   | 7     | ✅ Partial (core) |
| `index.ts`            | 14    | —     | Barrel export     |

---

## 5. Findings by Dimension

### 5.1 Performance & Efficiency (Weight: 30) — Score: 27/30

```
Severity: MEDIUM
File: src/domains/media/roomMediaCluster.ts
Function: getConsumer()
Problem: Linear scan across all distribution routers for every consumer lookup
Evidence: `for (const dist of this.distributionRouters) { const c = dist.routerManager.getConsumer(consumerId); if (c) return c; }`
Impact: O(D×C) lookup on every consumer:resume. With 10+ dist routers, adds latency.
Fix: Add a cluster-level `Map<consumerId, DistributionRouter>` for O(1) lookup, similar to transportOwnership.
Complexity: 0.5 hours
```

```
Severity: LOW
File: src/domains/media/roomMediaCluster.ts
Function: findDistributionRouterForTransport()
Problem: Duplicate lookup — transportOwnership already maps transportId→RouterManager
Evidence: `for (const dist of this.distributionRouters) { if (dist.routerManager.getTransport(transportId)) { return dist; } }`
Impact: Minor: called only during consume(), but O(D) instead of O(1).
Fix: Change transportOwnership to map transportId → DistributionRouter instead of RouterManager.
Complexity: 0.5 hours
```

```
Severity: INFO
File: src/domains/media/activeSpeaker.ts
Function: computeTopN()
Problem: Stale speaker eviction runs on every dominantspeaker event (~every 200ms)
Evidence: `for (const [id, entry] of this.recentSpeakers) { if (entry.lastActiveAt < staleCutoff) { this.recentSpeakers.delete(id); } }`
Impact: Negligible — Map is small (≤ total speakers in room). Already O(N) and N ≤ 15 typically.
Fix: No action required. Could batch eviction to every 5th event if profiling shows hot path.
Complexity: N/A
```

### 5.2 Architecture & Scalability (Weight: 20) — Score: 17/20

```
Severity: MEDIUM
File: src/domains/media/roomMediaCluster.ts
Function: registerConsumer()
Problem: registerConsumer() registers on the first distribution router only, ignoring transport ownership
Evidence: `for (const dist of this.distributionRouters) { dist.routerManager.registerConsumer(consumer); return; }`
Impact: External consumers registered on wrong router. Not used in practice (internal consume() path is correct), but the API is misleading.
Fix: Either remove this method (it's unused), or accept a transportId parameter to find the correct dist router.
Complexity: 0.25 hours
```

```
Severity: LOW
File: src/domains/media/roomMediaCluster.ts
Function: canConsume()
Problem: Only checks piped producer on first distribution router (index 0)
Evidence: `const dist = this.distributionRouters[0];`
Impact: Not a bug — all distribution routers have the same piped producers. But adding a comment would improve clarity.
Fix: Add a comment explaining the invariant (all dist routers have identical piped producer sets).
Complexity: 0.1 hours
```

```
Severity: LOW
File: src/domains/media/routerManager.ts
Function: RouterManager
Problem: Dual ownership of activeSpeakerDetector reference (both RouterManager and RoomMediaCluster store it)
Evidence: Both `RouterManager.setActiveSpeakerDetector()` and `RoomMediaCluster.setActiveSpeakerDetector()` exist
Impact: Confusing ownership. RouterManager's copy is never called (the detector is wired from RoomManager → RoomMediaCluster).
Fix: Remove `activeSpeakerDetector` from `RouterManager` — it's dead code. Only `RoomMediaCluster` owns the detector.
Complexity: 0.25 hours
```

### 5.3 Realtime Correctness (Weight: 15) — Score: 14/15

```
Severity: MEDIUM
File: src/domains/media/media.handler.ts
Function: audioProduceHandler
Problem: No authorization check that socket user is allowed to produce (e.g. is a seated speaker)
Evidence: `const producer = await transport.produce({ kind, rtpParameters, appData: { userId: socket.data.user.id } });`
Impact: Any authenticated user could produce audio even if not seated. The seat domain may enforce this separately, but the media handler doesn't verify.
Fix: Add a guard: verify the user has a seat before allowing produce. Or document that seat enforcement is handled upstream.
Complexity: 0.5 hours
```

```
Severity: LOW
File: src/domains/media/media.handler.ts
Function: selfMuteHandler
Problem: No verification that the requesting socket owns the producerId being muted
Evidence: `const producer = cluster?.getProducer(producerId);`
Impact: Any user with a valid producerId could mute another user's producer. Low risk since producerIds are UUIDs and not easily guessable.
Fix: Verify `producer.appData.userId === socket.data.user.id` before allowing pause.
Complexity: 0.25 hours
```

### 5.4 Code Quality (Weight: 15) — Score: 13/15

```
Severity: MEDIUM
File: src/domains/media/media.handler.ts, routerManager.ts, activeSpeaker.ts
Function: Multiple
Problem: No dedicated unit tests for media.handler.ts, routerManager.ts, or activeSpeaker.ts
Evidence: Only `roomMediaCluster.test.ts` exists with 7 tests
Impact: Regression risk on handler logic, router lifecycle, and active speaker edge cases.
Fix: Add test files for remaining 3 modules. Priority: activeSpeaker.ts (sliding window logic is most testable).
Complexity: 3 hours
```

```
Severity: LOW
File: src/domains/media/media.handler.ts
Function: audioProduceHandler
Problem: producer.on('transportclose') calls producer.close() but producer may already be closing
Evidence: `producer.on("transportclose", () => { ... producer.close(); });`
Impact: Double-close is silently handled by mediasoup, but adds unnecessary complexity.
Fix: Check `if (!producer.closed)` before calling `producer.close()`, matching the pattern in roomMediaCluster.ts line 273.
Complexity: 0.1 hours
```

### 5.5 Security & Reliability (Weight: 10) — Score: 8/10

```
Severity: MEDIUM
File: src/domains/media/media.handler.ts
Function: transportCreateHandler
Problem: No limit on number of transports a single client can create
Evidence: Any authenticated socket can call transport:create repeatedly
Impact: A malicious client could exhaust server resources by creating thousands of transports.
Fix: Add a per-client transport limit (e.g., max 2: one producer + one consumer). Check `client.transports.size` before creating.
Complexity: 0.25 hours
```

```
Severity: LOW
File: src/domains/media/roomMediaCluster.ts
Function: consume()
Problem: Error messages include transport/producer IDs that could leak internal state
Evidence: `throw new Error(\`Transport ${transportId} not found on any distribution router\`);`
Impact: Minimal — errors are caught by createHandler and not sent to clients directly.
Fix: Return `{ success: false, error: "Transport not found" }` instead of throwing, matching the pattern in handler.
Complexity: 0.25 hours
```

### 5.6 Readability (Weight: 10) — Score: 8/10

```
Severity: INFO
File: src/domains/media/roomMediaCluster.ts
Function: Class-level
Problem: File is 549 lines — the largest in the domain. Well-organized with section headers but approaching maintainability threshold.
Evidence: 8 Maps/Sets for internal state tracking
Impact: Cognitive load for new developers. Not yet a problem but worth monitoring.
Fix: No action needed now. If it grows beyond ~600 lines, consider extracting pipe transport logic into a PipeTransportManager.
Complexity: N/A
```

```
Severity: INFO
File: src/domains/media/index.ts
Function: Barrel export
Problem: RoomMediaCluster is not exported from barrel despite being the primary class
Evidence: Only exports: mediaHandler, RouterManager, ActiveSpeakerDetector
Impact: Consumers import directly from `roomMediaCluster.ts` instead of the barrel.
Fix: Add `export { RoomMediaCluster } from "./roomMediaCluster.js";` to index.ts.
Complexity: 0.1 hours
```

---

## 6. Over-Engineering Penalties

No significant over-engineering detected. The multi-router cluster architecture is justified by the scaling requirements (unlimited listeners per room, multi-core utilization).

```
File: src/domains/media/routerManager.ts
Anti-pattern: Duplicate activeSpeakerDetector tracking (dead code)
Runtime cost: None (8 bytes per instance)
Dev-hours/year: 1
Score deduction: 0
```

---

## 7. Aggregate Scores

| Dimension                  | Weight  | Score | Weighted |
| -------------------------- | ------- | ----- | -------- |
| Performance & Efficiency   | 30      | 27    | 27       |
| Architecture & Scalability | 20      | 17    | 17       |
| Realtime Correctness       | 15      | 14    | 14       |
| Code Quality               | 15      | 13    | 13       |
| Security & Reliability     | 10      | 8     | 8        |
| Readability                | 10      | 8     | 8        |
| **Total**                  | **100** |       | **87**   |

---

## 8. Priority Remediation Queue

| Priority | Severity | Finding                                                                 | Est. Hours |
| -------- | -------- | ----------------------------------------------------------------------- | ---------- |
| P1       | MEDIUM   | Add per-client transport creation limit                                 | 0.25       |
| P2       | MEDIUM   | Verify producer ownership in selfMute/selfUnmute                        | 0.25       |
| P3       | MEDIUM   | Add O(1) consumer→dist router lookup map                                | 0.5        |
| P4       | MEDIUM   | Remove dead `registerConsumer()` on cluster or fix it                   | 0.25       |
| P5       | MEDIUM   | Add unit tests for activeSpeaker.ts, routerManager.ts, media.handler.ts | 3.0        |
| P6       | LOW      | Remove dead activeSpeakerDetector from RouterManager                    | 0.25       |
| P7       | LOW      | Add producer ownership check in selfMute handler                        | 0.25       |
| P8       | LOW      | Export RoomMediaCluster from barrel index.ts                            | 0.1        |
| P9       | LOW      | Guard double-close on producer in audioProduceHandler                   | 0.1        |
| P10      | INFO     | Document canConsume() invariant with comment                            | 0.1        |

**Total estimated remediation: ~5.05 hours**
