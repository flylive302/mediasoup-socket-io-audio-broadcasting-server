# Elite Domain Forensic Audit — FlyLive Audio Server

**Date:** 2026-02-12  
**Commit:** `47ea8cc7614d686af55ad1d51ea4cba29d20e99f`  
**Branch:** `work` (tracking `origin/stagging`)  
**Node.js:** v24.12.0

---

## 1. Executive Summary

The FlyLive Audio Server is a well-architected, production-ready real-time audio broadcasting platform built on **Mediasoup 3.15 + Socket.IO 4.8 + Fastify 5**. The codebase demonstrates strong engineering discipline: zero `console.log` leaks, zero `TODO/FIXME` markers, consistent Zod validation, atomic Lua scripts for seat management, and a sophisticated multi-router media cluster with active speaker forwarding.

**Overall Score: 87/100** — The server is production-grade with several HIGH-priority items that would improve reliability under extreme load and a handful of MEDIUM optimizations to reduce latency and Redis round-trips.

| Dimension                      | Weight   | Score | Weighted |
| ------------------------------ | -------- | ----- | -------- |
| Performance & Scalability      | 30%      | 83    | 24.9     |
| Architecture & Patterns        | 25%      | 90    | 22.5     |
| Real-time Correctness          | 20%      | 85    | 17.0     |
| Code Quality & Maintainability | 15%      | 92    | 13.8     |
| Security & Auth                | 10%      | 88    | 8.8      |
| **Total**                      | **100%** |       | **87.0** |

---

## 2. Context Metadata

| Property       | Value                                        |
| -------------- | -------------------------------------------- |
| Runtime        | Node.js ESM (ES2024 / NodeNext)              |
| HTTP Framework | Fastify 5                                    |
| Realtime Stack | Socket.IO 4.8 + @socket.io/redis-adapter 8.3 |
| Media Stack    | Mediasoup 3.15                               |
| Redis Client   | ioredis 5.4                                  |
| Metrics        | prom-client 15.1                             |
| Logger         | pino 9.5                                     |
| Validation     | zod 3.24                                     |
| Auth           | JWT (HMAC-SHA256, local verification)        |
| Test Framework | Vitest 3.2                                   |
| Build Tool     | tsup 8.3 / tsx 4.19                          |

---

## 3. Domain Coverage Matrix

| Domain       | Handler                                       | Repository/Manager                                                                        | Types           | Tests | Coverage |
| ------------ | --------------------------------------------- | ----------------------------------------------------------------------------------------- | --------------- | ----- | -------- |
| Room         | `room.handler.ts`                             | `roomManager.ts`, `roomState.ts`                                                          | —               | ✅    | Full     |
| Media        | `media.handler.ts`                            | `routerManager.ts`, `roomMediaCluster.ts`, `activeSpeaker.ts`                             | —               | ✅    | Full     |
| Seat         | `seat.handler.ts` (junction) + 9 sub-handlers | `seat.repository.ts`, `seat.owner.ts`                                                     | `seat.types.ts` | ✅    | Full     |
| Gift         | `giftHandler.ts`                              | `giftBuffer.ts`                                                                           | —               | ✅    | Full     |
| Chat         | `chat.handler.ts`                             | —                                                                                         | —               | ✅    | Full     |
| User         | `user.handler.ts`                             | —                                                                                         | —               | ✅    | Full     |
| Auto-Close   | —                                             | `auto-close.service.ts`, `auto-close.job.ts`                                              | —               | ✅    | Full     |
| Integrations | —                                             | `laravelClient.ts`, `event-subscriber.ts`, `event-router.ts`, `user-socket.repository.ts` | `types.ts`      | ✅    | Full     |

---

## 4. Findings by Dimension

### 4.1 Performance & Scalability

---

#### PERF-010 — Gift `findInviteByUser` Uses SCAN Loop With Serial GETs

```
ID:        PERF-010
Severity:  HIGH
Dimension: Performance
File:      src/domains/seat/seat.repository.ts
Function:  SeatRepository.findInviteByUser (L495-L530)
```

**Problem:** `findInviteByUser` uses `SCAN` to discover invite keys, then issues a **serial** `GET` for each key inside the loop. Under high seat invite volumes, this becomes O(N) Redis round-trips.

**Evidence:**

```typescript
for (const key of keys) {
  const data = await this.redis.get(key);  // Serial GET per key
```

**Impact:** Each SCAN page triggers up to 100 individual GET calls. In a room with 20 pending invites, this is 20+ Redis round-trips instead of 1.

**Fix:** Use `MGET` on each page of SCAN results, or better, maintain a reverse index `room:{roomId}:invite:user:{userId}` → `seatIndex` for O(1) lookup.

**Complexity:** Low (MGET) / Medium (reverse index)

---

#### PERF-011 — AutoCloseService.getInactiveRoomIds Issues N×2 Parallel Redis Calls

```
ID:        PERF-011
Severity:  MEDIUM
Dimension: Performance
File:      src/domains/room/auto-close/auto-close.service.ts
Function:  AutoCloseService.getInactiveRoomIds (L76-L112)
```

**Problem:** After SCAN discovers all `room:state:*` keys, the method fires `Promise.all` with 2 Redis calls per room (`EXISTS` + `GET`). With 500 rooms, this is 1000 concurrent Redis calls in a single tick.

**Evidence:**

```typescript
const checks = await Promise.all(
  roomIds.map(async (roomId) => {
    const [hasAct, count] = await Promise.all([
      this.hasActivity(roomId),       // EXISTS call
      this.getParticipantCount(roomId), // GET + JSON.parse call
    ]);
```

**Impact:** Redis connection pool pressure under high room counts. Could cause pipeline stalls or connection exhaustion.

**Fix:** Use a Redis pipeline to batch all EXISTS + GET calls into a single round-trip. Process the results array locally.

**Complexity:** Low

---

#### PERF-012 — GiftHandler Transaction ID Uses Math.random()

```
ID:        PERF-012
Severity:  LOW
Dimension: Performance
File:      src/domains/gift/giftHandler.ts
Function:  GiftHandler.handle (L53)
```

**Problem:** Transaction ID generation uses `Math.random().toString(36).substr(2, 5)` which is non-cryptographic and has ~60M possible values — collision risk under high gift volume.

**Evidence:**

```typescript
transaction_id: `g_${Date.now()}_${socket.id}_${Math.random().toString(36).substr(2, 5)}`,
```

**Impact:** Low collision probability in practice since `socket.id` adds uniqueness, but `Date.now()` has millisecond granularity. Two gifts from the same socket in the same millisecond have a 1-in-60M collision chance.

**Fix:** Use `crypto.randomUUID()` (already imported in `chat.handler.ts`) for guaranteed uniqueness.

**Complexity:** Trivial

---

#### PERF-013 — Lua Script Strings Re-parsed on Every Invocation

```
ID:        PERF-013
Severity:  LOW
Dimension: Performance
File:      src/domains/seat/seat.repository.ts
Function:  Multiple (takeSeat, leaveSeat, assignSeat)
```

**Problem:** The top-level Lua scripts (`TAKE_SEAT_LUA`, `LEAVE_SEAT_LUA`, `ASSIGN_SEAT_LUA`) are module-level constants, but `redis.eval()` sends the full script text on every call. Redis must re-hash to check its script cache.

**Evidence:** Three large Lua scripts at module scope, invoked via `this.redis.eval(TAKE_SEAT_LUA, ...)`.

**Impact:** Marginal — Redis caches scripts by SHA, so the actual execution path uses cache after the first call. But the full script text is sent over the wire every time.

**Fix:** Use `redis.defineCommand()` or `EVALSHA` with pre-loaded SHA to send only the hash (40 bytes vs ~500 bytes per call).

**Complexity:** Low

---

### 4.2 Architecture & Patterns

---

#### ARCH-010 — Gift Domain Uses Class-Based Handler While Others Use createHandler

```
ID:        ARCH-010
Severity:  MEDIUM
Dimension: Architecture
File:      src/domains/gift/giftHandler.ts
Function:  GiftHandler class
```

**Problem:** `GiftHandler` is a class that registers its own `.on()` handlers internally, bypassing the `createHandler` pattern used by seat, room, and media domains. This means gift events lack the centralized validation, error handling, correlation IDs, and metrics that `createHandler` provides.

**Evidence:**

```typescript
// Gift handler does its own validation inline
socket.on("gift:send", async (rawPayload: unknown) => {
  // Manual rate limit, manual Zod parse, manual socket.emit("error")
```

**Impact:** Inconsistent error response shape for gift events. No correlation ID in gift logs. No callback/ack support — errors are emitted via `socket.emit("error")` while other domains use callbacks.

**Fix:** Refactor `GiftHandler` to use `createHandler` for the `gift:send` event, keeping the class for lifecycle management of the `GiftBuffer`. The `gift:prepare` handler can use `createHandler` with a simple passthrough.

**Complexity:** Medium

---

#### ARCH-011 — chatHandler Also Bypasses createHandler

```
ID:        ARCH-011
Severity:  LOW
Dimension: Architecture
File:      src/domains/chat/chat.handler.ts
Function:  chatHandler
```

**Problem:** Same issue as ARCH-010 — chat handler uses direct `.on()` with inline validation, emitting errors via `socket.emit("error")` instead of callbacks.

**Impact:** Inconsistent error response pattern. Frontend must handle both callback-style and emit-style errors.

**Fix:** Migrate to `createHandler` pattern.

**Complexity:** Low

---

#### ARCH-012 — Domain Registry Does Not Include GiftHandler Registration

```
ID:        ARCH-012
Severity:  INFO
Dimension: Architecture
File:      src/domains/index.ts
Function:  domains array (L23-L29)
```

**Problem:** The `domains` array in the domain registry includes `registerSeatHandlers`, `roomHandler`, `mediaHandler`, `chatHandler`, and `userHandler` — but `GiftHandler` is registered separately in `socket/index.ts` because it's a class with lifecycle methods. This creates an asymmetry.

**Evidence:** `GiftHandler` instantiation and `.handle(socket)` call happens in `socket/index.ts`, outside the domain registry pattern.

**Impact:** Minor — new developers must look in two places to find all event registrations.

**Fix:** Document this intentional asymmetry in the domain registry, or create a `DomainWithLifecycle` interface.

**Complexity:** Trivial

---

### 4.3 Real-time Correctness

---

#### RT-010 — LaravelClient.canManageRoom Makes Two Sequential HTTP Calls

```
ID:        RT-010
Severity:  HIGH
Dimension: Real-time Correctness
File:      src/integrations/laravelClient.ts
Function:  LaravelClient.canManageRoom (L206-L220)
```

**Problem:** `canManageRoom` first calls `getRoomData()` (HTTP GET) to check ownership, and if that fails or doesn't match, makes a second `getMemberRole()` call. Each has a 5-second timeout. In the worst case, a non-owner admin's seat action takes **two sequential HTTP round-trips** before the seat mutation can proceed.

**Evidence:**

```typescript
async canManageRoom(roomId: string, userId: string): Promise<boolean> {
  try {
    const roomData = await this.getRoomData(roomId);  // HTTP call 1
    if (String(roomData.owner_id) === userId) return true;
  } catch { }
  const role = await this.getMemberRole(roomId, userId);  // HTTP call 2
  return role === 'admin';
}
```

**Impact:** P99 latency for admin seat actions is double that of owner actions. With Laravel at 50ms per call, this adds 100ms+ to every admin action.

**Fix:**

1. Use `fetchRoomOwner()` which has a 30-second cache (already implemented in `seat.owner.ts`) instead of raw `getRoomData()`.
2. Consider a combined API endpoint that returns both ownership and role in a single call.
3. Cache admin roles similarly to owner cache.

**Complexity:** Low (use existing cache) / Medium (combined endpoint)

---

#### RT-011 — Owner Cache TTL Comment Mismatch

```
ID:        RT-011
Severity:  LOW
Dimension: Real-time Correctness
File:      src/domains/seat/seat.owner.ts
Function:  setRoomOwner (L28-L32)
```

**Problem:** The comment says "5 minutes for manually set owners" but the actual calculation is `30_000 * 10 = 300_000ms = 5 minutes`. The base `OWNER_CACHE_TTL_MS` is 30 seconds, so the magic number `10` is non-obvious.

**Evidence:**

```typescript
const OWNER_CACHE_TTL_MS = 30_000;
// ...
expiresAt: Date.now() + OWNER_CACHE_TTL_MS * 10, // 5 minutes for manually set owners
```

**Impact:** Readability/maintenance risk. If someone changes `OWNER_CACHE_TTL_MS`, the `setRoomOwner` TTL changes by 10x unexpectedly.

**Fix:** Extract `OWNER_BOOTSTRAP_TTL_MS = 300_000` as a named constant.

**Complexity:** Trivial

---

#### RT-012 — No Backpressure on Laravel Event Subscriber

```
ID:        RT-012
Severity:  MEDIUM
Dimension: Real-time Correctness
File:      src/integrations/laravel/event-subscriber.ts
Function:  LaravelEventSubscriber.start (L50-L67)
```

**Problem:** The `message` handler calls `this.onEvent(event)` synchronously without awaiting. If `EventRouter.route()` is slow (e.g., Redis lookup for user sockets), events pile up in the Node.js microtask queue with no backpressure mechanism.

**Evidence:**

```typescript
this.subscriber.on("message", (channel, message) => {
  // ...
  this.onEvent(event);  // Fire-and-forget, no await
```

**Impact:** Under burst traffic from Laravel (e.g., mass ban event), memory pressure could build. However, `onEvent` calls `EventRouter.route()` which is async but uses `.emit()` (non-blocking), so actual risk is low.

**Fix:** Add an event queue with bounded size, or at minimum a counter metric for unprocessed events.

**Complexity:** Medium

---

### 4.4 Code Quality & Maintainability

---

#### CQ-010 — `emitToRoom` Utility in `socket.utils.ts` Not Used by All Domains

```
ID:        CQ-010
Severity:  LOW
Dimension: Code Quality
File:      src/shared/socket.utils.ts
Function:  emitToRoom
```

**Problem:** The `emitToRoom` utility exists to DRY-up "emit to room including sender" but several handlers still use `socket.to(roomId).emit()` + `socket.emit()` directly, or use `socket.nsp.to(roomId).emit()`. The utility is underutilized.

**Evidence:** `chat.handler.ts` uses `socket.nsp.to(payload.roomId).emit()` which includes the sender via namespace. `giftHandler.ts` uses `socket.to(payload.roomId).emit()` which excludes the sender.

**Impact:** Inconsistent broadcast patterns. `emitToRoom` uses `socket.to() + socket.emit()` (2 emissions), while `socket.nsp.to()` uses 1 emission via the namespace adapter.

**Fix:** Standardize on `socket.nsp.to(roomId).emit()` when sender should be included (more efficient — single adapter call). Update `emitToRoom` or deprecate it in favor of the namespace pattern.

**Complexity:** Low

---

#### CQ-011 — Seat Handler Sub-modules Not Reviewed in Domain Registry

```
ID:        CQ-011
Severity:  INFO
Dimension: Code Quality
File:      src/domains/seat/seat.handler.ts
Function:  registerSeatHandlers
```

**Problem:** The seat domain registers 11 event handlers across 9 separate sub-handler files. This is the most granular decomposition in the codebase. Each sub-handler is small (30-70 lines), which is good for single-responsibility but creates navigation overhead.

**Impact:** None functionally. Good separation of concerns, but the directory has 12+ files for one domain vs 1-3 for others.

**Fix:** Consider documenting the pattern rationale for future contributors. No code change needed — this is well-structured.

**Complexity:** N/A

---

### 4.5 Security & Auth

---

#### SEC-010 — JWT Revocation Check Is Fail-Closed But Not Monitored

```
ID:        SEC-010
Severity:  MEDIUM
Dimension: Security
File:      src/auth/jwtValidator.ts
Function:  verifyJwtInternal (L122-L134)
```

**Problem:** If Redis is unreachable during the revocation check, the JWT validator returns `null` (fail-closed). This is the correct security posture, but there's no metric tracking how often this happens. A Redis outage would silently reject all connections.

**Evidence:**

```typescript
} catch (err) {
  logger.error({ err }, "JWT: Redis error during revocation check");
  return null;  // Fail closed for security
}
```

**Impact:** During a Redis partition, 100% of new connections are rejected without any Prometheus metric to alert on. The error log exists but operational dashboards may miss it.

**Fix:** Add `metrics.authAttempts.inc({ result: "redis_error" })` to this catch block.

**Complexity:** Trivial

---

#### SEC-011 — Origin Validation Allows Missing Origin Header

```
ID:        SEC-011
Severity:  LOW
Dimension: Security
File:      src/auth/middleware.ts
Function:  authMiddleware (L14-L22)
```

**Problem:** Connections without an `Origin` header are explicitly allowed (documented as intentional for mobile/server-to-server). However, this means a browser extension or script without CORS could connect if it omits the Origin header.

**Evidence:**

```typescript
const origin = socket.handshake.headers.origin;
if (origin && !config.CORS_ORIGINS.has(origin)) {
  // Block
}
// No origin = allowed through
```

**Impact:** Low — JWT auth is still required, so this is defense-in-depth. The comment documents the rationale well.

**Fix:** No change recommended. The comment at L15-L16 correctly explains the design decision.

**Complexity:** N/A

---

### 4.6 Reliability & Error Handling

---

#### REL-010 — GiftBuffer.flush Catches Rename "no such key" via String Matching

```
ID:        REL-010
Severity:  MEDIUM
Dimension: Reliability
File:      src/domains/gift/giftBuffer.ts
Function:  GiftBuffer.flush (L60-L70)
```

**Problem:** The flush method catches the "empty queue" case by string-matching `"no such key"` in the error message. This is fragile — Redis error messages may vary by locale, version, or proxy.

**Evidence:**

```typescript
} catch (e: unknown) {
  const errorMessage = e instanceof Error ? e.message : String(e);
  if (errorMessage.toLowerCase().includes("no such key")) {
    return;  // Empty queue, normal case
  }
```

**Impact:** If Redis changes its error message format, the empty-queue case would log as an unexpected error instead of returning silently.

**Fix:** Check the key existence with `EXISTS` before `RENAME`, or use a Lua script that atomically checks and renames. Alternatively, catch the Redis error code `ERR` specifically.

**Complexity:** Low

---

#### REL-011 — metrics.giftsProcessed Incremented in a Loop

```
ID:        REL-011
Severity:  LOW
Dimension: Reliability
File:      src/domains/gift/giftBuffer.ts
Function:  GiftBuffer.flush (L97-L101)
```

**Problem:** Success count is incremented one-by-one in a loop instead of a single `.inc({}, successCount)` call.

**Evidence:**

```typescript
const successCount = transactions.length - result.failed.length;
for (let i = 0; i < successCount; i++) {
  metrics.giftsProcessed.inc({ status: "success" });
}
```

**Impact:** Marginal CPU waste for large batches. `prom-client` Counter.inc() accepts a numeric value.

**Fix:** `metrics.giftsProcessed.inc({ status: "success" }, successCount);`

**Complexity:** Trivial

---

#### REL-012 — roomHandler and mediaHandler Differ in Error Response Pattern

```
ID:        REL-012
Severity:  LOW
Dimension: Reliability
File:      src/domains/room/room.handler.ts, src/domains/media/media.handler.ts
```

**Problem:** `roomHandler` registers events using `socket.on("room:join", async (rawPayload, callback) => {...})` with direct inline validation. `mediaHandler` uses `createHandler` via seat-style patterns. Both work but produce different log shapes and error formats.

**Impact:** Frontend must handle slightly different error response structures from different domains.

**Fix:** When migrating `roomHandler` to `createHandler` (already planned), ensure the callback shape is standardized.

**Complexity:** Low

---

## 5. Over-Engineering Penalties

No significant over-engineering found. The codebase is lean and fit-for-purpose.

| File | Anti-pattern | Runtime Cost | Dev-hours/yr | Deduction |
| ---- | ------------ | ------------ | ------------ | --------- |
| —    | —            | —            | —            | **0**     |

The multi-router `RoomMediaCluster` is appropriately complex for its purpose (scaling beyond single-worker listener limits). The `createHandler` abstraction is justified by the 9+ seat handlers it serves. The Lua scripts are necessary for atomicity.

---

## 6. Aggregate Scores

| Dimension          | Weight | Raw Score | Notes                                                                |
| ------------------ | ------ | --------- | -------------------------------------------------------------------- |
| Performance        | 30%    | 83        | SCAN-serial-GET pattern in seat invites; auto-close N×2 Redis burst  |
| Architecture       | 25%    | 90        | Excellent domain separation; minor handler pattern inconsistency     |
| Real-time          | 20%    | 85        | Double HTTP in canManageRoom; no event backpressure                  |
| Code Quality       | 15%    | 92        | Zero console.log, zero TODO; consistent Zod; good barrel exports     |
| Security           | 10%    | 88        | Solid JWT + revocation; fail-closed; missing metric on Redis failure |
| **Weighted Total** |        | **87.0**  |                                                                      |

---

## 7. Priority Remediation Queue

| Priority | ID       | Severity | Effort  | Description                                                                   |
| -------- | -------- | -------- | ------- | ----------------------------------------------------------------------------- |
| 1        | RT-010   | HIGH     | Low     | Cache admin roles or use combined API to avoid double HTTP in `canManageRoom` |
| 2        | PERF-010 | HIGH     | Low     | Replace serial GETs with MGET in `findInviteByUser`                           |
| 3        | SEC-010  | MEDIUM   | Trivial | Add metric for Redis failures during JWT revocation check                     |
| 4        | REL-010  | MEDIUM   | Low     | Replace string-matching "no such key" with proper error handling              |
| 5        | PERF-011 | MEDIUM   | Low     | Pipeline Redis calls in `getInactiveRoomIds`                                  |
| 6        | ARCH-010 | MEDIUM   | Medium  | Migrate `GiftHandler` to `createHandler` pattern                              |
| 7        | RT-012   | MEDIUM   | Medium  | Add backpressure/metric for Laravel event subscriber                          |
| 8        | REL-011  | LOW      | Trivial | Use `.inc({}, count)` for batch gift metrics                                  |
| 9        | PERF-012 | LOW      | Trivial | Use `crypto.randomUUID()` for gift transaction IDs                            |
| 10       | RT-011   | LOW      | Trivial | Extract `OWNER_BOOTSTRAP_TTL_MS` constant                                     |
| 11       | ARCH-011 | LOW      | Low     | Migrate `chatHandler` to `createHandler`                                      |
| 12       | PERF-013 | LOW      | Low     | Use `EVALSHA` for pre-hashed Lua scripts                                      |
| 13       | CQ-010   | LOW      | Low     | Standardize broadcast patterns on `socket.nsp.to()`                           |

---

## 8. Strengths (Not Findings)

These are areas where the codebase excels — **no action required**:

- ✅ **Active Speaker Forwarding** — O(k×N) top-N selection reduces consumer CPU by only forwarding top speakers
- ✅ **Atomic Lua Scripts** — Seat take/leave/assign/lock/mute all use atomic Lua, preventing race conditions
- ✅ **Gift Buffering with DLQ** — Batch processor with retry counts and dead-letter queue is production-grade
- ✅ **Redis Pipeline Usage** — Room cleanup, user socket registration, and gift re-queue all use pipelines
- ✅ **`createHandler` Pattern** — Centralized validation, error handling, correlation IDs, and timing metrics
- ✅ **O(1) Room-indexed Client Lookup** — `ClientManager.roomClients` secondary index avoids O(totalClients) scans
- ✅ **Graceful Shutdown** — Proper cleanup of HTTP, Socket.IO, Mediasoup workers, and Redis
- ✅ **CORS + JWT + Revocation** — Defense-in-depth auth with timing-safe signature comparison
- ✅ **SCAN over KEYS** — All Redis key discovery uses non-blocking SCAN
- ✅ **Domain Registry** — Static registration with zero runtime overhead

---

## CLI Reproduction Commands

```bash
# Static analysis
npx depcheck
npm audit --audit-level=high

# Type checking
npx tsc --noEmit

# Tests
npx vitest run

# Memory profiling
node --inspect dist/index.js
clinic doctor -- node dist/index.js

# Load testing
autocannon -c 100 -d 30 http://localhost:3030/health
```
